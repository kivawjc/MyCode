### 1.写日志引发的故障

**故障现象**:应用服务器发布后不久就出现了多台服务器相机报警，磁盘可用空间低于预警值，并且很快就有服务器宕机。登录到线上服务器，**发现log文件夹的文件迅速增加，不断消耗磁盘空间**。

**原因分析**:这是一个普通的应用服务器群，不需要存储数据，因此服务器里配置的是一块100GB的小硬盘，安装完操作系统、WEB服务器、Java虚拟机、应用程序后，空闲空间只有几十GB了，正常情况这些磁盘空间足够了，但是**应用的开发人员将log输出的level全局配置成Debug**。这样一次简单的Web请求就会产生大量的log文件输出。

在高并发的用户请求下，很快就消耗完不多的磁盘空间了。

**经验教训**:

应用程序自己的日志输出和第三方组件日志输出要分别配置

检查log配置文件，日志输出级别至少为Warn,并且检查log输出代码调用，调用级别要符合其真实日志级别。

有些开源的第三方组件也会不切当地输出太多的Error日志，需要关闭这些第三方库的日志输出，至于那些第三方库有问题，只有在遇到问题的时候才知道。

 

### 2.高并发访问数据库引发的故障

**故障现象**:应用发布后，数据库Load居高不下，远超过正常水平，持续报警。

**原因分析**：检查数据库，发现报警时某条SQL引起的,这条SQL是一条简单的有索引的数据查询,不应该引发报警。继续检查，发现这天SQL执行频率非常高，远远超过正常水平。追查这条SQL,发现被网站首页应用调用，首页是访问最频繁的网页，这条SQL被首页调用，也就频繁执行了.

**经验教训**:

首页不应该访问数据库，首页需要的数据可以从缓存服务器或者搜索服务器获取，最好是静态的.

 

### 3.高并发情况下引发的故障

**故障现象**:应用服务器不定时因为响应超时而报警，但是很快又超时解除，恢复正常，如此反复，让运维人员非常苦恼.

**原因分析**：程序中某个单利对象中多处使用了synchronized(this),由于this对象只有一个，所有的并发请求都需要排队获得这唯一的一把锁。一般情况下，都是一些简单操作，获得锁，迅速完成操作，释放锁，不会引起线程排队。但是某个需要远程调用的操作也被加了synchronized(this)，这个操作知识偶尔会执行，但是每次执行都需要较长时间才能完成，这段时间锁被占用，所有的用户线程都需要等待，响应超时，这个操作执行完成后释放锁，其他线程迅速执行，超时解除。

**经验教训**:

使用锁操作需要谨慎.

### 4.缓存引发的故障

**故障现象**:没有新应用发布，但是数据库服务器土壤Load飙升，并很快失去响应，DBA讲数据库访问切换到备机，Load也很苦熬飙升，并失去响应，最终引发网站全部瘫痪.

**原因分析**:缓存服务器在网站服务器集群的地位一致比较低，服务器配置和管理级别都别其他服务器要低一些。人们都认为缓存是改善性能的手段，失去一些缓存也没有什么问题，有时候关闭一两台缓存服务器对应用没有明显的影响，所以长期疏于管理缓存服务器。结果这次一个缺乏经验的工程师关闭所有缓存服务器集群中的全部十台服务器，导致网站全部瘫痪的重大事故(启动很多请求就直接到数据库了.)

**经验教训**:当缓存已经不仅仅是改善性能，而是成为网站架构不可或缺的一部分，对缓存管理就㤇提高到和其他服务器的级别.

 

### 5.大文件读写独占磁盘引发的故障

**故障现象**:应用主要功能就是管理用户图片，接到部分用户投诉，表示商城图片非常慢，原来需要一两秒，现在需要几十秒，有时候等半天结果浏览器显示服务器超时。

**原因分析**:图片需要存储，最有可能出现的地方就是存储服务器。检查存储服务器，发现大部分文件只有几百KB，而有几个文件非常大，有数百兆，读写这些发文件一次需要几十秒，这段时间磁盘基本被这个文件独占，导致其他用户的操作非常缓慢.

**经验教训**:

存储的服务需要根据不同文件类型和用户进行管理，图片都是小文件，应该使用专用的存储服务器，不能喝大文件公用存储。批处理用的大文件可以使用其他类型的分布式系统。

 